

/****************************************************************
* This code is automatically generated by "mGenero"
* at Thu, 27 May 2021 16:43:02.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/****************************************************************

Copyright (c) 2018 Stanford University. All rights reserved.

The information and source code contained herein is the 
property of Stanford University, and may not be disclosed or
reproduced in whole or in part without explicit written 
authorization from Stanford University.

* Filename   : amplifier.template.sv
* Author     : Byongchan Lim (bclim@stanford.edu)
* Description: SV template for an amplifier cell

* Note       :

* Todo       :
  - 

* Revision   :
  - 00/00/00 : 

****************************************************************/
/*******************************************************
* An amplifier with possible output equalization
* - Input referred voltage offset as a static parameter
* - Gain Compression
* - Dynamic behavior (a pole or two-poles with a zero)
* - 

* Calibrating metrics:
* 1. Av = gm*Rout 
* 2. Max output swing = Itail*Rout 
* 3. fp1, fp2, fz1
*******************************************************/

// These imports added 5/5/2021
`include "mLingua_pwl.vh"
`include "pwl_add.v"
`include "pwl2real.v"
`include "real2pwl.v"
`include "pwl_vga.v"
`include "pwl_filter_real_w_reset.v"

module ctle #(
  parameter real etol_f = 0.0001, // error tolerance of a filter
  parameter real etol_v_icm = 0.01, // resolution of input common-mode voltage (inp+inn)/2.0
  parameter real etol_vdd = 0.01, // resolution of vdd
  parameter real v_os = 0.0 // input-referred static offset voltage
) (
  input real  vinn, // Template: "inn", Circuit: "vinn"
  input real  vinp, // Template: "inp", Circuit: "vinp"
  output real  voutn, // Template: "outn", Circuit: "voutn"
  output real  voutp, // Template: "outp", Circuit: "voutp"
  input real  v_fz, // Template: "None", Circuit: "v_fz"
  input real  vdd, // Template: "None", Circuit: "vdd"
  input real  vss // Template: "None", Circuit: "vss"
);

`protect
//pragma protect 
//pragma protect begin

`get_timeunit
PWLMethod pm=new;

// map pins between generic names and user names, if they are different
real inn ;
real inp ;
real outn ;
real outp ;
assign inn = vinn ;
assign inp = vinp ;
assign voutn = outn ;
assign voutp = outp ; 

// assert optional ports are in range

reg assert_clk;
event assert_event;

always @(assert_event) begin
    #1
    assert_clk = 1;
    #1;
    assert_clk = 0;
end
  
always @(v_fz) ->> assert_event;
always @(vdd) ->> assert_event;
always @(vss) ->> assert_event;
always @(posedge assert_clk) begin
    assert property (v_fz >= 0.4);
    assert property (v_fz <= 1.4);
    assert property (vdd >= 1.764);
    assert property (vdd <= 1.836);
    assert property (vss >= 0.0);
    assert property (vss <= 0.0);
end 

// edited 5/5/2021 to make create outp_pwl and outn_pwl
// because I want inputs to be real, not pwl. Changed references in code from outp to outp_pwl
pwl inp_pwl;
pwl inn_pwl;
pwl outp_pwl;
pwl outn_pwl;
// TODO don't hard code etol here
real2pwl #(.tr(10e-12)) xr2p_inp (.in(inp), .out(inp_pwl));
real2pwl #(.tr(10e-12)) xr2p_inn (.in(inn), .out(inn_pwl));
pwl2real #(.dv(0.0001)) xp2r_outp (.in(outp_pwl), .out(outp));
pwl2real #(.dv(0.0001)) xp2r_outn (.in(outn_pwl), .out(outn));

//----- BODY STARTS HERE -----

//----- SIGNAL DECLARATION -----
pwl ONE = `PWL1;
pwl ZERO = `PWL0;

pwl v_id_lim;   // limited v_id 
pwl v_oc; // output common-mode voltage
pwl v_od; // output differential voltage
pwl vid_max, vid_min; // max/min of v_id for slewing 
pwl vop, von;
pwl v_od_filtered;
pwl vop_lim, von_lim;
pwl v_id, v_icm; // differential and common-mode inputs

real t0;
real v_icm_r;
real vdd_r;

real fz1, fp1, fp2; // at most, two poles and a zero
real Av;    // voltage gain (gm*Rout)
real max_swing; // Max voltage swing of an output (Itail*Rout)
real vid_r; // vid<|vid_r| (max_swing/Av)
real v_oc_r;  // common-mode output voltage

event wakeup;

//----- FUNCTIONAL DESCRIPTION -----

initial ->> wakeup; // dummy event for ignition at t=0

//-- Compute differential and common-mode voltages 

  pwl _v_id[3]; pwl _v_icm[2]; real _k_v_id[3]; real _k_v_icm[2];
  assign _k_v_id = '{1.0, -1.0, v_os};
  assign _k_v_icm = '{0.5, 0.5};
  assign _v_id = '{inp_pwl, inn_pwl, ONE};
  assign _v_icm = '{inp_pwl, inn_pwl};
// diff/cm sense considering input referred offset
pwl_add #(.no_sig(3)) xidiff (.in(_v_id), .scale(_k_v_id), .out(v_id));
pwl_add #(.no_sig(2)) xicm (.in(_v_icm), .scale(_k_v_icm), .out(v_icm));

//-- System's parameter calculation

// discretization of control inputs
pwl2real #(.dv(etol_v_icm)) xp2r_v_icm (.in(v_icm), .out(v_icm_r)); // pwl-to-real of v_icm

// not necessary since inputs are now reals anyway
//pwl2real #(.dv(etol_vdd)) xp2r_vdd (.in(vdd), .out(vdd_r)); // pwl-to-real of vdd
assign vdd_r = vdd;

// Not used anywhere anyway?
//

// updating parameters as control inputs/mode inputs change

always @(v_icm_r, vdd_r, wakeup, vss, v_fz, vdd) begin
  t0 = `get_time;

  Av = 3.064039389565759*1-3.359216833699701*v_fz+1.2286346056215702*v_fz*v_fz;
  v_oc_r = 1.2999103684417914*1+0.0003110695874539715*v_fz-0.0001579016499810848*v_fz*v_fz;
  fp1 = 3433122020.9820547*1-866280289.6200409*v_fz+306884904.25160027*v_fz*v_fz;
  fp2 = 2046772956.6521676*1-44169184.29102421*v_fz+25203030.668548584*v_fz*v_fz;
  fz1 = 998198134.6766971*1-1064486119.926903*v_fz+399497671.4514488*v_fz*v_fz;

end

//-- Model behaviors

assign v_id_lim = v_id; // gain compression is not implemented

pwl_vga xgain (.in(v_id_lim), .scale(Av), .out(v_od)); // differential-mode gain stage 

pwl_filter_real_w_reset #(.etol(etol_f), .en_filter(1'b1), .filter(2)) xfilter (.fz1(fz1), .fp1(fp1), .fp2(fp2), .fp_rst(0.0), .in(v_od), .in_rst(ZERO), .out(v_od_filtered), .reset(1'b0)); // differential output filtering

real2pwl #(.tr(10e-12)) r2poc (.in(v_oc_r), .out(v_oc)); // output common-mode voltage

// combine differential and common-mode output
  pwl _v_od[2]; real _k_v_od_1[2]; real _k_v_od_2[2];
  assign _v_od = '{v_oc, v_od_filtered};

  assign _k_v_od_1 = '{1.0, 0.5};
  assign _k_v_od_2 = '{1.0, -0.5};

pwl_add #(.no_sig(2)) xoutp (.in(_v_od), .scale(_k_v_od_1), .out(outp_pwl));
pwl_add #(.no_sig(2)) xoutn (.in(_v_od), .scale(_k_v_od_2), .out(outn_pwl));

//pragma protect end
`endprotect

endmodule

